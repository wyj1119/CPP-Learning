# 类和对象

属性和行为作为一个整体

## 访问权限

1. public：谁都能用。做接口API用
2. private：只有自己能用。存数据用（默认安全选项）。
3. protected：只有家族（继承链）能用。给子类留后门用。

**struct和class的唯一区别就是默认权限，struct默认是public而class是private**

**通常将对象属性设置为private，在public中提供读写接口函数**

## 构造函数和析构函数

说人话就是对象的初始化和清理

* 构造函数`class_name(){}`：主要作用在于创建对象时为成员赋初值，编译器在构件类时自动调用
  1. 没有返回值也不写void
  2. 函数名与类名相同
  3. 构造函数可以有参数，因此可以发生重载
  4. 创建对象时自动调用构造，且只调用一次

* 析构函数`~class_name(){}`：在对象销毁前执行的清理工作，也有编译器自动调用
  1. 没有返回值也不写void
  2. 函数名与类名相同，名称前加上 `~`
  3. 析构函数不能有参数，因此不能发生重载
  4. 对象销毁时自动调用析构，且只调用一次

## 拷贝构造函数

```cpp
class Person{
    public:
    //普通构造函数
        Person(){
			age = 0;
        }
    	Person(int age_i){
			age = age_i;
        }
    //拷贝构造函数
        Person(const Person &P){
			age = P.age;
        }
    	~Person(){
            cout << "destroy a Person class" << endl;
        }
    private:
    	int age;
};
```

调用时需要注意

```cpp
int main(){
    Person p1;//使用本行代码调用无参构造函数
    //Person p1();//这种写法不能创建对象的,编译器会将这行代码识别为函数的声明(返回值类型Person,函数名p1的函数声明)。
    Person p2(10);//调用有参构造函数
    Person p3(p2);//调用拷贝构造函数
    return 0;
}
```

显示法调用

```cpp
Person p4 = Person(2);
Person p5 = Person(p4);
```

隐式法调用

```cpp
Person p6 = 10;//隐式转换法调用构造函数 本行代码相当于 Person p6 = Person(10);
Person p7 = p6;//隐式转换法调用拷贝构造函数 本行代码相当于 Person p6 = Person(p6);
```

## 深拷贝与浅拷贝

* 浅拷贝：简单的赋值拷贝操作

  ```cpp
  #include <iostream>
  #include <string>
  using namespace std;
  
  class Person{
      public:
      //普通构造函数
          Person(){
              Height = new int(160);
  			age = 0;
          }
      	Person(int age_i,int H_i){
  			age = age_i;
              Height = new int(160);
          }
      //使用默认的拷贝构造函数
      	~Person(){
              if(Height != NULL){
                  delete Height;
                  Height = NULL;
              }
              cout << "destroy a Person class" << endl;
          }
          
  //   private:
      	int age;
          int *Height;
  };
  
  
  int main(){
      Person p1(22,160);//这里释放第二次，Error！
      cout << "age:" << p1.age << "\nheight:" << *p1.Height << endl;
  
      Person p2(p1);//这里释放第一次
      cout << "age:" << p2.age << "\nheight:" << *p2.Height << endl;
      return 0;
  }
  ```

  使用默认的拷贝构造函数会出现浅拷贝问题，可能导致堆区数据重复释放。

  在调用拷贝构造函数创建新的对象时，处理器将逐字节将源对象复制到新对象，当这个对象的属性中含有指针时也会拷贝这个指针（相当于两个指针指向同一块内存）。但程序结束时调用两次析构函数，也就对同一块内存释放了两次，从而产生错误。

  ![image-20251205160814340](.\figures\shallow_copy.png)

* 深拷贝：在堆区重新申请空间，进行拷贝操作

  ```cpp
  //拷贝构造函数
      Person(const Person &P){
          age = P.age;
          Height = new int(*P.Height);
      }
  ```

  自行实现拷贝构造函数，在堆区为自己的属性指针分配一块内存即可

  ***若属性有在堆区开辟空间，一定要自己提供拷贝构造函数，防止出现浅拷贝问题！***

## 初始化列表

`Person(const Person &P):age(P.age), height(P.height), weight(P.weight)`

```cpp
#include <iostream>
using namespace std;

class Person{
    public:
    	Person(int a_i, int h_i, int w_i):age(a_i), height(h_i), weight(w_i){
            cout << "age:" << age << endl;
            cout << "height:" << height << endl;
            cout << "weight:" << weight << endl;
        };
    	Person(const Person &P):age(P.age), height(P.height), weight(P.weight){
            cout << "age:" << age << endl;
            cout << "height:" << height << endl;
            cout << "weight:" << weight << endl;
        };
    	int age;
    	int height;
    	int weight;
};

int main()
{
    Person p1(22,178,67);
    Person p2(p1);
    return 0;
}
```

## 类对象作为类成员

* 当其他类对象作为本类成员，构造的时候先构造其他类对象，再构造自身，析构顺序与构造相反。

## 类的静态成员

* #### 静态成员变量

1. 在编译阶段分配内存

2. 类内声明，类外初始化

3. 所有对象共享同一份数据


* #### 静态成员函数

1. 程序共享一个函数
2. 静态成员函数只能访问静态成员变量
3. 两种访问方式

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person{
    public:
    	Person(int a_i, int h_i, int w_i):age(a_i), height(h_i), weight(w_i){
            person_num++;
            cout << "age:" << age << endl;
            cout << "height:" << height << endl;
            cout << "weight:" << weight << endl;
        };
    	Person(const Person &P):age(P.age), height(P.height), weight(P.weight){
            person_num++;
            cout << "age:" << age << endl;
            cout << "height:" << height << endl;
            cout << "weight:" << weight << endl;
        };
    	int age;
    	int height;
    	int weight;
        static int person_num;//类内声明

        static void print_num(){
            cout << person_num << endl;
        }
    
    private:
        static string pass_word;
};

//类外初始化
int Person::person_num = 0;
string Person::pass_word = "10086";

class Empyt_Class{
    
};
int main()
{
    Person p1(22,178,67);
    Person p2(p1);
    Person p3(p1);
    Person p4(p1);
    Person p5(p1);
    Person p6(p1);
    Person p7(p1);
    cout << "total person num:" << Person::person_num << endl;
    cout << "total person num:" << p1.person_num << endl;
    cout << "total person num:" << p7.person_num << endl;
    //Person::pass_word;//不可访问

    Person::print_num();
    p1.print_num();

    cout << "class size:" << sizeof(p1) << endl;//结果为3*4个字节 即是3个int 也就说明了成员变量和静态变量分开存储

    Empyt_Class class_test;
    cout << "empty class size:" << sizeof(class_test) << endl;//空对象的占用内存1个字节
    return 0;
}//输出的person_num都为7
```

* 只有**非静态**的**成员变量**才属于类；静态成员变量、静态/非静态成员函数都不属于类

* 空对象的占用内存1个字节

## this指针

this指针指向	被调用的成员函数	所属***对象***

* 形参和成员变量同名，可用this指针来区分

  ```cpp
  #include <iostream>
  using namespace std;
  
  class Person{
      public:
          Person(int age){
              //age = age;
              this->age = age;//解决重名冲突
          }
  
          int age;
  };
  
  int main()
  {
      Person p1(22);
      cout << "age of p1:" << p1.age << endl;
      return 0;
  }
  ```

* 在类的非静态成员函数中返回对象本身，可使用`return *this`

```cpp
#include <iostream>
using namespace std;

class Person{
    public:
        Person(int age){
            //age = age;
            this->age = age;//解决重名冲突
        }
        Person& PersonAddAge(const Person &p){
            this->age += p.age;
            return *this;//返回这个对象
        }
        Person* PersonAddAge_return_ptr(const Person &p){
            this->age += p.age;
            return this;//返回指向这个对象的指针
        }
        int age;
};

int main()
{
    Person p1(22);
    Person p2(16);
    cout << "age of p1:" << p1.age << endl;

    p1.PersonAddAge(p2).PersonAddAge(p2).PersonAddAge(p2);//链式编程 22+16+16+16
    cout << "after age of p1:" << p1.age << endl;

    p2.PersonAddAge_return_ptr(p1)->PersonAddAge_return_ptr(p1)->PersonAddAge_return_ptr(p1);
    cout << "after age of p2:" << p2.age << endl;
    return 0;
}
```

### 空指针访问成员函数

```cpp
#include <iostream>
using namespace std;

class Person{
    public:

        void print_class_name(){
            cout << "Person" << endl;
        }
        void print_age(){
            if(this == NULL){
                cout << "this ptr is NULL!" << endl;
                return;
            }      
            cout << "age:" << this->m_Age << endl;
        }
        int m_Age;
};

int main(){
    Person *ptr = NULL;
    ptr->print_class_name();//空指针能够访问这个函数
    ptr->print_age();//由于this是空指针，访问this指针时会出错，可添加判断条件来规避
    return 0;
}
```

## const 修饰成员函数

### 常函数

* 成员函数***后面***加const称为常函数
* 常函数内不能修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person{
    public:
        Person(int age){
            //age = age;
            this->age = age;//解决重名冲突
            this->judge = "no judgement";
        }
        
        void showPerson() const{
            //this指针本身是一个指针常量 Person* const this
            //this->age = 100;//该函数传入的this指针是const Person* const this，即常量指针常量，不能更改指向和指向对象的值
            cout << "age:" << this->age << endl;
        }

        void showGoodJudge() const{
            this->judge = "he is a very nice people";
            cout << "Judge:" << this->judge << endl;
        }
        int age;
        mutable string judge;//加mutable的特殊变量，常函数中也能修改该值
};      

int main()
{
    Person p1(22);
    Person p2(16);
    p1.showPerson();
    p1.showGoodJudge();
    return 0;
}
```

this指针本身是一个指针常量 Person* const this，this的指向不能修改

该函数传入的this指针是const Person* const this，即常量指针常量，不能更改指向和指向对象的值

加mutable的特殊变量，常函数中也能修改该值

### 常对象

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数

```cpp
#include <iostream>
#include <string>
using namespace std;

class Person{
    public:
        Person(int age){
            //age = age;
            this->age = age;//解决重名冲突
            this->judge = "no judgement";
        }
        
        void set_age(int age){
            this->age = age;
        }

        void showPerson() const{
            //this指针本身是一个指针常量 Person* const this
            //this->age = 100;//该函数传入的this指针是const Person* const this，即常量指针常量，不能更改指向和指向对象的值
            cout << "age:" << this->age << endl;
        }

        void showGoodJudge() const{
            this->judge = "he is a very nice people";
            cout << "Judge:" << this->judge << endl;
        }
        int age;
        mutable string judge;//加mutable的特殊变量，常函数中也能修改该值
};      

int main()
{
    Person p1(22);
    const Person p2(16);
    p1.showPerson();
    p1.showGoodJudge();

    p2.judge = "he is not so good";
    cout << "judgement of p2:" << p2.judge << endl;

    //p2.set_age(100);//常对象只能调用常函数，若调用非常函数则有可能更改属性，与常对象规则不符
    return 0;
}
```

常对象只能调用常函数，若调用非常函数则有可能更改属性，与常对象规则不符

## 友元

让类外的一些函数或者类访问私有属性

* 全局函数作友元

* 类作友元

* 成员函数作友元

```cpp
#include <iostream>
#include <string>
using namespace std;

class Building;

class BadGay{
    public:
        BadGay();
        void visit_building();
        void visit_building_with_gun();
    private:
        Building *b;
};

class Building{
    friend void visit_func_global(const Building &b);
    friend void BadGay::visit_building_with_gun();
    friend class GoodGay;
    public:
        Building(){
            this->m_SittingRoom = "101";
            this->m_BedRoom = "102";
        }
        Building(string num_SittingRoom, string num_BedRoom){
            this->m_SittingRoom = num_SittingRoom;
            this->m_BedRoom = num_BedRoom;
        }

        string m_SittingRoom;
    private:
        string m_BedRoom;
};


class GoodGay{
    public:
        GoodGay();
        void visit_building();
    private:
        Building *b;
};

GoodGay::GoodGay(){
    this->b = new Building("110","111");
}

void GoodGay::visit_building(){
    cout << "GoodGay visit SittingRoom Num:" << this->b->m_SittingRoom << endl;
    cout << "GoodGay visit BedRoom Num:" << this->b->m_BedRoom << endl;
}

BadGay::BadGay(){
    this->b = new Building("220","221");
}

void BadGay::visit_building(){
    cout << "BadGay visit SittingRoom Num:" << this->b->m_SittingRoom << endl;
    cout << "BadGay can not visit BedRoom" << endl;
}
void BadGay::visit_building_with_gun(){
    cout << "BadGay visit SittingRoom Num:" << this->b->m_SittingRoom << endl;
    cout << "BadGayWithGun visit BedRoom Num:" << this->b->m_BedRoom << endl;
}

void visit_func_global(const Building &b)
{
    cout << "Golbal visit SittingRoom Num:" << b.m_SittingRoom << endl;
    cout << "Golbal visit BedRoom Num:" << b.m_BedRoom << endl;
}


int main()
{
    Building b1;
    visit_func_global(b1);

    GoodGay gg;
    gg.visit_building();
    
    BadGay bg;
    bg.visit_building();
    bg.visit_building_with_gun();
    
    return 0;
}
```

注意一个声明顺序问题，若`BadGay`类的对象在`Building`类之后定义，那么声明成员函数作为友元函数时`friend void BadGay::visit_building_with_gun();`编译器不知道BadGay内部构造，不知道是否有这个函数存在

