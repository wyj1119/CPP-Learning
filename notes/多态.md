# 多态

当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态允许使用基类指针或引用来调用子类的重写方法，从而使得同一接口可以表现不同的行为。

```cpp
#include <iostream>
#include <string>
using namespace std;


class AbstractCal{
    public:
        virtual double getResult(){
            return 0;
        }
        double num1;
        double num2;
};

class AddCal : public AbstractCal{
    public:
        double getResult() override{
            return num1 + num2;
        }
};

class SubCal : public AbstractCal{
    public:
        double getResult() override {
            return num1 - num2;
        }
};

class Multical : public AbstractCal{
    public:
        double getResult() override {
            return num1 * num2;
        }
};

int main(){
    AbstractCal *Cal = new Multical;
    Cal->num1 = 10.0;
    Cal->num2 = 3.14;
    cout << Cal->num1 << " * " << Cal->num2 << " = " << Cal->getResult() << endl;
    delete Cal;

    Cal = new AddCal;
    Cal->num1 = 10.0;
    Cal->num2 = 3.14;
    cout << Cal->num1 << " + " << Cal->num2 << " = " << Cal->getResult() << endl;
    delete Cal;

    return 0;
}
```

虚函数签名不匹配的错误通常是因为 **函数名、参数列表 或 const 属性**不一样，导致意外创建了一个新的虚函数，而不是重写一个已存在的虚函数。

针对上述情况，C++ 11 增加了两个继承控制关键字：`override `和` final`，两者的作用分别为：

- `override`：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名
- `final`：阻止类的进一步派生 和 虚函数的进一步重写

## 虚函数

定义他为**虚函数**是为了允许用基类的指针来调用子类的这个函数

虚函数通过虚函数指针（vfptr）和虚函数表（vftable）实现

## 纯虚函数

`virtual 返回值类型 函数名 (参数列表) = 0;`

在多态中，通常纯虚函数的实现是毫无意义的，主要都是调用子类重写的内容。

定义**纯虚函数**是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

### 抽象类

当类中有了纯虚函数，这个类也称为抽象类

1. 抽象类无法实例化
2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

```cpp
#include <iostream>
#include <string>
using namespace std;

class Base{
    public:
        virtual void func() = 0;
};

class SonVirtual : public Base{
    
};

class Son : public Base{
    public:
        virtual void func() override {
            cout << "I am son of Base" << endl;
        };
};

int main(){
    Base &b = *new Son;
    b.func();

    Base *bptr = new Son;
    bptr->func();

    return 0;
}

```

一旦在基类中声明为虚函数，该函数在所有派生类中自动成为虚函数，无论是否使用 virtual 关键字

建议在重写时加上virtual关键字提高代码可读性

## 虚析构和纯虚析构

问题：子类在堆区有数据，需要调用子类析构函数释放内存，但多态中父类指针在释放时不会调用子类析构函数，导致内存泄露

虚析构和纯虚析构则可以实现父类指针释放子类对象，即delete父类指针时会先调用子类的析构再调用父类析构

```cpp
#include <iostream>
#include <string>
using namespace std;
class Animal{
    public:
        Animal(){
            AnimalNum++;
            cout << "Animal constructor called\t AnimalNum:" << this->AnimalNum <<endl;
        }        
        virtual ~Animal(){
            this->AnimalNum--;
            cout << "Animal destructor callded\t AnimalNum:" << this->AnimalNum << endl;
        }

        static int AnimalNum;
};
int Animal :: AnimalNum = 0;

class Cat : public Animal{
    public:
        Cat(string Name){
            this->Name = new string(Name);
            cout << "Cat constructor called" << endl;
        }         
        ~Cat() override {
            if(this->Name != NULL){
                delete this->Name;
                this->Name = NULL;
                cout << "Cat destructor called" << endl;
            }
        }

        string *Name;
};

class Dog : public Animal{
    public:
        Dog(string Name){
            this->Name = new string(Name);
            cout << "Dog constructor called" << endl;
        }         
        ~Dog() override {
            if(this->Name != NULL){
                delete this->Name;
                this->Name = NULL;
                cout << "Dog destructor called" << endl;
            }
        }

        string *Name;
};

int main(){
    Animal *a1 = new Cat("Tom");
    Animal *a2 = new Dog("Judy");
    delete(a1);
    delete(a2);
    return 0;
}
```

上述代码中子类析构函数不加virtual关键字会导致子类中的成员`string *Name`不被释放，导致内存泄漏

