# 继承

`class 子类 : 继承方式 父类`

继承允许我们依据一个类来定义另一个类，减少重复代码

当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承一个已有的类的成员即可，已有的类称为**基类**，新建的类称为**派生类**

```cpp
#include <iostream>
#include <string>
using namespace std;

class Animal {
    public:
        void eat() {
            cout << "the animal is eating" << endl;
        }
        void sleep() {
            cout << "the animal is sleeping" << endl;
        }
};

class Dog : public Animal {
    public:
        void bark(){
            cout << "the dog is barking" << endl;
        }
};

class Cat : public Animal {
    public:
        void jump(){
            cout << "the cat is jumping" << endl;
        }
};

int main(){
    Dog d1;
    d1.eat();
    d1.sleep();
    d1.bark();

    Cat c1;
    c1.eat();
    c1.sleep();
    c1.jump();
    return 0;
}
```

## 继承方式

父类中私有内容子类都无法访问。

* 公有继承：当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。

* 保护继承：当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。

* 私有继承：当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

![image-20251207155055832](.\figures\inheritance.png)

* 继承中构造和析构顺序：现有父亲后有儿子；析构顺序和构造相反

```cpp
#include <iostream>
using namespace std;

class Son : public Base {
    public:
        Son(){
            cout << "Son constructor called" << endl;
        }
        ~Son(){
            cout << "Son destructor called" << endl;
        }

};

void test_base_son(){
    Son s1;
}
int main(){
    test_base_son();
    return 0;
}
```

* 同名成员访问需要加作用域

```cpp
#include <iostream>
using namespace std;

class Base{
    public:
    	Base(){
            this->m_Num = 10;
        }
    	Base(int num){
            this->m_Num = num;
        }
    	int m_Num;
        static int m_SNum;
};
int Base::m_SNum = 100;

class Son : public Base{
    public:
    	Son(){
            this->m_Num = 1000;
        }
    	Son(int num){
            this->m_Num = num;
        }
    	int m_Num;
        static int m_SNum;
};
int Son::m_SNum = 200;

int main(){
    Son s1;
    cout << "Son num:" << s1.m_Num << endl;
    cout << "Base num:" << s1.Base::m_Num << endl;
//通过对象访问静态成员
    cout << "Son static num:" << s1.m_SNum << endl;
    cout << "Base static num:" << s1.Base::m_SNum << endl;
//通过类名访问静态成员
    cout << "Son static num:" << Son::m_SNum << endl;
    cout << "Base static num:" << Base::m_SNum << endl;
    cout << "Base static num:" << Son::Base::m_SNum << endl;
	return 0;
}
```

## 多继承语法

一个类继承多个类：`class 类名 : 继承方式1 父类1, 继承方式2 父类2, ...`

可能出现重名，需要加作用域区分，不建议使用

### 菱形继承（钻石继承）

![image-20251207163308565](.\figures\菱形继承.png)

两个派生类继承同一个基类，又有另外一个类继承这两个派生类。

![image-20251207163613225](.\figures\菱形继承案例.png)

问题：

1. 羊和驼都继承了年龄属性，草泥马使用时会出现二义性
2. 草泥马继承了两个年龄属性，实际上这种动物只需要一个年龄属性就够了

解决方法：虚继承

```cpp
#include <iostream>
using namespace std;

class Animal{
    public:
        Animal(){
            this->m_Age = 0;
            cout << "Animal constructor called" << endl;
        }
        ~Animal(){
            cout << "Animal destructor called" << endl;
        }
        int m_Age;
};

class Sheep : virtual public Animal{
    public:
        Sheep(){
            this->m_Age = 10;
            cout << "Sheep constructor called" << endl;
        }
        ~Sheep(){           
            cout << "Sheep destructor called" << endl;
        }
};

class Camel : virtual public Animal{
    public:
        Camel(){
            this->m_Age = 20;
            cout << "Camel constructor called" << endl;
        }
        ~Camel(){
            cout << "Camel destructor called" << endl;
        }
};

class SheepCamel : public Sheep, public Camel{
    public:
        SheepCamel(){
            cout << "SheepCamel constructor called" << endl;
        }
        ~SheepCamel(){
            cout << "SheepCamel destructor called" << endl;
        }
};
class CamelSheep : public Camel, public Sheep{
    public:
        CamelSheep(){
            cout << "CamelSheep constructor called" << endl;
        }
        ~CamelSheep(){
            cout << "CamelSheep destructor called" << endl;
        }
};


int main(){
    Sheep s1;
    Camel c1;
    SheepCamel sc1;
    CamelSheep cs1;
    cout << "Animal age:" << s1.Animal::m_Age << endl;
    cout << "Animal age:" << c1.Animal::m_Age << endl;

    cout << "Animal age:" << sc1.m_Age << endl;

    cout << "Animal age:" << cs1.m_Age << endl;
    return 0;
}
```

* 构造顺序是代码中的继承顺序
* 与普通继承不同，虚继承中派生类对象并不是在其内存中保留一份虚基类数据的副本，而是通过一种间接的引用方式，即将虚基类子对象的数据单独存放，在派生类对象中设置一个指针指向基类子对象。这样，当一个派生类通过多个继承路径继承同一个虚基类时，并不需要产生多个数据副本，而只要维护这个虚基类指针即可。

